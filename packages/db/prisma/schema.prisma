generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/* ===== Enums ===== */

enum Role {
  SUPER_ADMIN
  IT_MANAGER
  HR_MANAGER
  DIRECTOR
  MANAGER
  EMPLOYEE
  CEO
}

enum AttendanceType {
  CLOCK_IN
  CLOCK_OUT
}

enum AttendanceSource {
  MOBILE
  WEB
  KIOSK
}

enum LeaveType {
  HOURLY
  DAILY
}

enum LeaveStatus {
  PENDING
  APPROVED
  REJECTED
  CANCELLED
}

enum CorrectionAction {
  ADD
  UPDATE
  DELETE
}

/* ===== Core Org Models ===== */

model Organization {
  id          String        @id @default(cuid())
  name        String        @unique
  departments Department[]
  users       User[]
  workSites   WorkSite[]
  calendars   WorkCalendar[]
  holidays    Holiday[]

  // Back-relations
  leaveRequests       LeaveRequest[]
  attendanceCorrections AttendanceCorrection[]

  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
}

model Department {
  id        String        @id @default(cuid())
  orgId     String
  org       Organization  @relation(fields: [orgId], references: [id], onDelete: Cascade)
  name      String
  parentId  String?
  users     User[]

  // Back-relations
  roleAssignments       RoleAssignment[]
  leaveRequests         LeaveRequest[]
  attendanceCorrections AttendanceCorrection[]

  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt

  @@unique([orgId, name])
}

model User {
  id            String           @id @default(cuid())
  orgId         String
  org           Organization     @relation(fields: [orgId], references: [id], onDelete: Cascade)

  email         String           @unique
  name          String
  phone         String?
  passwordHash  String?
  isActive      Boolean          @default(true)
  timeZone      String?
  departmentId  String?
  department    Department?      @relation(fields: [departmentId], references: [id])

  roles         RoleAssignment[]
  attendance    AttendanceEvent[]

  // Leave relations (two relations to User → must be named)
  leaves        LeaveRequest[]   @relation("LeaveRequester")
  approvals     LeaveRequest[]   @relation("LeaveApprover")

  // Corrections relations (two relations to User → must be named)
  corrections             AttendanceCorrection[] @relation("CorrectionRequester")
  correctionApprovals     AttendanceCorrection[] @relation("CorrectionApprover")

  // Audit & auth
  auditLogs     AuditLog[]       @relation("AuditActor")
  Session       Session[]

  // Calendars
  CalendarAssignment CalendarAssignment[]

  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt
}

model RoleAssignment {
  id           String       @id @default(cuid())
  userId       String
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  role         Role
  departmentId String?
  department   Department?  @relation(fields: [departmentId], references: [id])
  createdAt    DateTime     @default(now())

  @@index([userId, role])
}

model WorkSite {
  id            String        @id @default(cuid())
  orgId         String
  org           Organization  @relation(fields: [orgId], references: [id], onDelete: Cascade)
  name          String
  latitude      Decimal       @db.Decimal(9, 6)
  longitude     Decimal       @db.Decimal(9, 6)
  radiusMeters  Int           @default(100)
  wifiSSIDs     String[]      // Postgres text[] (no native type needed)
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
}

model AttendanceEvent {
  id              String            @id @default(cuid())
  userId          String
  user            User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  type            AttendanceType
  source          AttendanceSource
  at              DateTime          @default(now())
  latitude        Decimal?          @db.Decimal(9, 6)
  longitude       Decimal?          @db.Decimal(9, 6)
  withinGeofence  Boolean?
  ip              String?
  wifiBSSID       String?
  notes           String?
  createdAt       DateTime          @default(now())

  // Back-relation from AttendanceCorrection.targetEvent
  corrections     AttendanceCorrection[]

  @@index([userId, at])
}

/* ===== Leave Requests ===== */

model LeaveRequest {
  id            String        @id @default(cuid())
  orgId         String
  org           Organization  @relation(fields: [orgId], references: [id], onDelete: Cascade)

  userId        String
  user          User          @relation("LeaveRequester", fields: [userId], references: [id], onDelete: Cascade)

  // snapshot routing scope at submit time
  departmentId  String?
  department    Department?   @relation(fields: [departmentId], references: [id])

  type          LeaveType
  status        LeaveStatus    @default(PENDING)

  startAt       DateTime       // inclusive
  endAt         DateTime       // exclusive
  reason        String?        @db.VarChar(500)

  approverId    String?
  approver      User?          @relation("LeaveApprover", fields: [approverId], references: [id])
  approverRole  String?
  decisionNote  String?
  decidedAt     DateTime?

  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt

  @@index([orgId, status])
  @@index([departmentId, status])
  @@index([userId, createdAt])
}

/* ===== Attendance Corrections ===== */

model AttendanceCorrection {
  id            String            @id @default(cuid())

  orgId         String
  org           Organization      @relation(fields: [orgId], references: [id], onDelete: Cascade)

  userId        String
  user          User              @relation("CorrectionRequester", fields: [userId], references: [id], onDelete: Cascade)

  departmentId  String?
  department    Department?       @relation(fields: [departmentId], references: [id])

  action        CorrectionAction

  // Optional target (for UPDATE / DELETE)
  targetEventId String?
  targetEvent   AttendanceEvent?  @relation(fields: [targetEventId], references: [id])

  // Proposed data (for ADD / UPDATE)
  proposedType  AttendanceType?
  proposedAt    DateTime?
  proposedNote  String?           @db.VarChar(500)

  status        LeaveStatus       @default(PENDING) // reuse statuses
  approverId    String?
  approver      User?             @relation("CorrectionApprover", fields: [approverId], references: [id])
  approverRole  String?
  decisionNote  String?
  decidedAt     DateTime?

  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt

  @@index([orgId, status])
  @@index([userId, createdAt])
}

/* ===== Audit & Session ===== */

model AuditLog {
  id        String   @id @default(cuid())
  actorId   String?
  actor     User?    @relation("AuditActor", fields: [actorId], references: [id])
  action    String
  entity    String
  entityId  String?
  data      Json?
  ip        String?
  createdAt DateTime @default(now())

  @@index([entity, entityId])
}

model Session {
  id         String   @id @default(cuid())
  userId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  tokenHash  String   @unique
  createdAt  DateTime @default(now())
  expiresAt  DateTime
  userAgent  String?
  ip         String?

  @@index([userId, expiresAt])
}

/* ===== Calendars & Holidays ===== */

model WorkCalendar {
  id           String             @id @default(cuid())
  orgId        String
  org          Organization       @relation(fields: [orgId], references: [id], onDelete: Cascade)
  name         String
  timezone     String             @default("Asia/Tehran")
  weekendDays  Int[]              // 0=Sun ... 6=Sat
  rules        CalendarRule[]
  assignments  CalendarAssignment[]
  createdAt    DateTime           @default(now())
  updatedAt    DateTime           @updatedAt

  @@unique([orgId, name])
}

model CalendarRule {
  id          String        @id @default(cuid())
  calendarId  String
  calendar    WorkCalendar  @relation(fields: [calendarId], references: [id], onDelete: Cascade)

  /// 0=Sunday ... 6=Saturday (match JS Date.getDay())
  weekday     Int

  /// Minutes from midnight (local to calendar.timezone). Null + isOff=true => day off.
  startMin    Int?
  endMin      Int?
  isOff       Boolean       @default(false)

  @@unique([calendarId, weekday])
}

model CalendarAssignment {
  id            String        @id @default(cuid())
  userId        String
  user          User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  calendarId    String
  calendar      WorkCalendar  @relation(fields: [calendarId], references: [id], onDelete: Cascade)

  /// Optional effective window (inclusive start, exclusive end)
  effectiveFrom DateTime?
  effectiveTo   DateTime?
  isPrimary     Boolean       @default(true)

  @@index([userId, effectiveFrom, effectiveTo])
}

model Holiday {
  id         String        @id @default(cuid())
  orgId      String
  org        Organization  @relation(fields: [orgId], references: [id], onDelete: Cascade)

  /// Store as UTC midnight for the local day represented (Jalali or Gregorian).
  date       DateTime
  name       String

  /// If true, `date` represents a Jalali day converted to UTC midnight.
  isJalali   Boolean       @default(true)

  /// Optional original Jalali string ("YYYY-MM-DD") for audit/UI.
  jalaliDate String?

  createdAt  DateTime      @default(now())

  @@unique([orgId, date])
}
